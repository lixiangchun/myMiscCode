
function cluster_dp(D, options)

% Alex R. and Alessandro. L Clustering by fast search and find of density peaks. Science 344, 1492 (2014)
% http://people.sissa.it/~laio/Research/Res_clustering.php
%
% Usage: cluster_dp(D, options)
%
% The first input argument D can be:
%    matrix with M samples and N observation. E.g. rows are samples and columns are genes.
%    D data structure generated by GISTIC2. Note: set `-smallmem 0` when running GISTIC2. 
% options is a struct with two params:
%    normr: if true perform row-based normalization
%    distance: compute distance matrix using `distance`
% 
% Two files are generated, i.e. CLUSTER_ASSIGNATION and DECISION_GRAPH.
%
% This function is derived from /Users/lixiangchun/Public/Software/matlab/cluster_dp_lixc.m
% 2016-05-19
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%clear all
close all
%x=dlmread('iris.dat.txt');

if exist('options','var')
	if ~isstruct(options)
		error('options must be a struct.')
	end
else
	options = struct;
end
options = impose_default_value(options, 'normr', false);
options = impose_default_value(options, 'distance', 'euclidean');
if isfield(D,'sdesc') & isfield(D,'dat')
	options.D = true;
else
	options.D = false;
end
options

if options.D   %% x is D data structure
	x = D.dat';
else
	x = D;
end

if options.normr
	x=normr(x);
end

[M,N] = size(x); % M: sample size, N: number of variable
xx = zeros(nchoosek(M,2), 3); 
pdistout = pdist(x, options.distance);

k = 1;
for i = 1:M 
	for j = (i+1):M
		%distmat(k,:) = [int64(i), int64(j), dist(k)];
		xx(k,:) = [i, j, pdistout(k)];
		k = k + 1;
	end
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


ND=max(xx(:,2));
NL=max(xx(:,1));
if (NL>ND)
  ND=NL;
end
N=size(xx,1);
for i=1:ND
  for j=1:ND
    dist(i,j)=0;
  end
end
for i=1:N
  ii=xx(i,1);
  jj=xx(i,2);
  dist(ii,jj)=xx(i,3);
  dist(jj,ii)=xx(i,3);
end
percent=2.0;
fprintf('average percentage of neighbours (hard coded): %5.6f\n', percent);

position=round(N*percent/100);
sda=sort(xx(:,3));
dc=sda(position);

fprintf('Computing Rho with gaussian kernel of radius: %12.6f\n', dc);


for i=1:ND
  rho(i)=0.;
end
%
% Gaussian kernel
%
for i=1:ND-1
  for j=i+1:ND
     rho(i)=rho(i)+exp(-(dist(i,j)/dc)*(dist(i,j)/dc));
     rho(j)=rho(j)+exp(-(dist(i,j)/dc)*(dist(i,j)/dc));
  end
end
%
% "Cut off" kernel
%
%for i=1:ND-1
%  for j=i+1:ND
%    if (dist(i,j)<dc)
%       rho(i)=rho(i)+1.;
%       rho(j)=rho(j)+1.;
%    end
%  end
%end

maxd=max(max(dist));

[rho_sorted,ordrho]=sort(rho,'descend');
delta(ordrho(1))=-1.;
nneigh(ordrho(1))=0;

for ii=2:ND
   delta(ordrho(ii))=maxd;
   for jj=1:ii-1
     if(dist(ordrho(ii),ordrho(jj))<delta(ordrho(ii)))
        delta(ordrho(ii))=dist(ordrho(ii),ordrho(jj));
        nneigh(ordrho(ii))=ordrho(jj);
     end
   end
end
delta(ordrho(1))=max(delta(:));
disp('Generated file:DECISION GRAPH')
disp('column 1:Density')
disp('column 2:Delta')

%% commented out by Li XC
%fid = fopen('DECISION_GRAPH', 'w');
%for i=1:ND
%   fprintf(fid, '%6.2f %6.2f\n', rho(i),delta(i));
%end
%fclose(fid);

disp('Select a rectangle enclosing cluster centers')
scrsz = get(0,'ScreenSize');
figure('Position',[6 72 scrsz(3)/4. scrsz(4)/1.3]);
for i=1:ND
  ind(i)=i;
  gamma(i)=rho(i)*delta(i);
end
subplot(3,1,1)
tt=plot(rho(:),delta(:),'o','MarkerSize',5,'MarkerFaceColor','k','MarkerEdgeColor','k');
title ('Decision Graph','FontSize',15.0)
xlabel ('\rho')
ylabel ('\delta')


subplot(3,1,1)
rect = getrect(1);
disp('Rectangle selected by user:') % added by Li XC
disp(rect); % added by Li XC
rhomin=rect(1);
deltamin=rect(2);
NCLUST=0;
for i=1:ND
  cl(i)=-1;
end
for i=1:ND
  if ( (rho(i)>rhomin) && (delta(i)>deltamin))
     NCLUST=NCLUST+1;
     cl(i)=NCLUST;
     icl(NCLUST)=i;
  end
end
fprintf('NUMBER OF CLUSTERS: %i \n', NCLUST);
disp('Performing assignation')

%assignation
for i=1:ND
  if (cl(ordrho(i))==-1)
    cl(ordrho(i))=cl(nneigh(ordrho(i)));
  end
end
%halo
for i=1:ND
  halo(i)=cl(i);
end
if (NCLUST>1)
  for i=1:NCLUST
    bord_rho(i)=0.;
  end
  for i=1:ND-1
    for j=i+1:ND
      if ((cl(i)~=cl(j))&& (dist(i,j)<=dc))
        rho_aver=(rho(i)+rho(j))/2.;
        if (rho_aver>bord_rho(cl(i))) 
          bord_rho(cl(i))=rho_aver;
        end
        if (rho_aver>bord_rho(cl(j))) 
          bord_rho(cl(j))=rho_aver;
        end
      end
    end
  end
  for i=1:ND
    if (rho(i)<bord_rho(cl(i)))
      halo(i)=0;
    end
  end
end
for i=1:NCLUST
  nc=0;
  nh=0;
  for j=1:ND
    if (cl(j)==i) 
      nc=nc+1;
    end
    if (halo(j)==i) 
      nh=nh+1;
    end
  end
  fprintf('CLUSTER: %i CENTER: %i ELEMENTS: %i CORE: %i HALO: %i \n', i,icl(i),nc,nh,nc-nh);
end

%% colormap names: parula, jet, hsv, pink, bone, gray, http://www.mathworks.com/help/matlab/ref/colormap.html
%% or colorbrewer: http://www.mathworks.com/matlabcentral/fileexchange/34087-cbrewer---colorbrewer-schemes-for-matlab
cmap=colormap('hsv');
for i=1:NCLUST
   ic=int8((i*64.)/(NCLUST*1.));
   subplot(3,1,1)
   hold on
   plot(rho(icl(i)),delta(icl(i)),'o','MarkerSize',8,'MarkerFaceColor',cmap(ic,:),'MarkerEdgeColor',cmap(ic,:));
end
subplot(3,1,2)
disp('Performing 2D nonclassical multidimensional scaling')
%Y1 = mdscale(dist, 2, 'criterion','metricstress');
Y1 = mdscale(dist, 2, 'criterion','metricstress', 'Start','random');
%Y1 = cmdscale(dist, 2);
plot(Y1(:,1),Y1(:,2),'o','MarkerSize',2,'MarkerFaceColor','k','MarkerEdgeColor','k');
%title ('2D Nonclassical multidimensional scaling','FontSize',15.0)
title('Multidimensional scaling','FontSize',15.0)
xlabel('X')
ylabel('Y')


for i=1:ND
 A(i,1)=0.;
 A(i,2)=0.;
end
for i=1:NCLUST
  nn=0;
  ic=int8((i*64.)/(NCLUST*1.));
  for j=1:ND
    if (halo(j)==i)
      nn=nn+1;
      A(nn,1)=Y1(j,1);
      A(nn,2)=Y1(j,2);
    end
  end
  hold on
  plot(A(1:nn,1),A(1:nn,2),'o','MarkerSize',2,'MarkerFaceColor',cmap(ic,:),'MarkerEdgeColor',cmap(ic,:));
end

%for i=1:ND
%   if (halo(i)>0)
%      ic=int8((halo(i)*64.)/(NCLUST*1.));
%      hold on
%      plot(Y1(i,1),Y1(i,2),'o','MarkerSize',2,'MarkerFaceColor',cmap(ic,:),'MarkerEdgeColor',cmap(ic,:));
%   end
%end
faa = fopen('CLUSTER_ASSIGNATION', 'w');
disp('Generated file:CLUSTER_ASSIGNATION')
disp('column 1:element id')
disp('column 2:cluster assignation without halo control')
disp('column 3:cluster assignation with halo control')
if options.D
disp('column 4:sample name')
end
for i=1:ND
   if options.D
   fprintf(faa, '%i %i %i %s\n',i,cl(i),halo(i),D.sdesc{i});
   else
   fprintf(faa, '%i %i %i\n',i,cl(i),halo(i));
   end
end
fclose(faa);

subplot(3,1,3)
%plot(gamma,1:length(gamma),'o','MarkerSize',5,'MarkerFaceColor','k','MarkerEdgeColor','k');
%plot(sort(gamma,2,'descend'), 'o', 'MarkerSize', 2);
plot(gamma)
title ('Decision Graph','FontSize',15.0)
xlabel ('n')
ylabel ('\gamma=\rho*\delta')


function S = impose_default_value(S,field,value,acceptable_values)
%
% impose_default_value(S,field,value)
%
% S is a struct
% if field does not exist, it is created with the given default value.
% if field does exist but is empty, it is given the default value.
% if field does exist but is nonempty, it is left alone.
%
% Mike Lawrence 2008-06-26
% modified 2009-07-02 to handle required fields
% modified 2011-11-10 to handle accepable values

% GISTIC software version 2.0
% Copyright (c) 2011 Gad Getz, Rameen Beroukhim, Craig Mermel, 
% Jen Dobson, Steve Schumacher, Nico Stransky, Mike Lawrence, 
% Gordon Saksena, Michael O'Kelly, Barbara Tabak
% All Rights Reserved.
%
% See the accompanying file LICENSE.txt for licensing details.


if ~isfield(S,field) || isempty(getfield(S,field))
  if ischar(value) & strcmp(value,'*required*')
    error('%s is a required field of P',field);
  else
    try
      S=setfield(S,field,value);
    catch me
      fprintf('Error setting field "%s"\n',field);
      disp(me);disp(me.message);
    end
  end
end

if exist('acceptable_values','var')
  av = acceptable_values;
  v = getfield(S,field);
  if ischar(v) && isnumeric(av)
    v = str2double(v);
    S = setfield(S,field,v);
  end
  if ~ischar(v) && ischar(av)
    error('%s is assigned value of different type than acceptable_values',field);
  end
  try
    ism = ismember(v,av);
  catch me
    error('%s is assigned value of different type than acceptable_values',field);
  end
  if ~ism
    fprintf('Acceptable values for %s:\n',field); disp(av);
    fprintf('Attempted to set to:\n'); disp(v)
    error('Invalid setting of %s',field);
  end
end
